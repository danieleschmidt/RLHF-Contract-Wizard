#!/bin/bash

# ========================================================================
# RLHF-Contract-Wizard Production Deployment Script
# Automated deployment with health checks, rollbacks, and monitoring
# Generated by TERRAGON SDLC MASTER PROMPT v4.0 - AUTONOMOUS EXECUTION
# ========================================================================

set -euo pipefail  # Exit on error, undefined vars, pipe failures

# ========================================================================
# Configuration and Environment Setup
# ========================================================================

# Script configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/../.." && pwd)"
DEPLOYMENT_DIR="${PROJECT_ROOT}/deployment"
K8S_DIR="${DEPLOYMENT_DIR}/k8s"
MONITORING_DIR="${DEPLOYMENT_DIR}/monitoring"

# Default configuration
DEFAULT_NAMESPACE="rlhf-contracts"
DEFAULT_IMAGE_TAG="v1.0.0"
DEFAULT_ENVIRONMENT="production"
DEFAULT_REGION="us-east-1"

# Load environment variables with defaults
NAMESPACE="${NAMESPACE:-$DEFAULT_NAMESPACE}"
IMAGE_TAG="${IMAGE_TAG:-$DEFAULT_IMAGE_TAG}"
ENVIRONMENT="${ENVIRONMENT:-$DEFAULT_ENVIRONMENT}"
REGION="${REGION:-$DEFAULT_REGION}"
DRY_RUN="${DRY_RUN:-false}"
SKIP_TESTS="${SKIP_TESTS:-false}"
FORCE_DEPLOY="${FORCE_DEPLOY:-false}"

# Kubernetes context
KUBE_CONTEXT="${KUBE_CONTEXT:-rlhf-prod-${REGION}}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# ========================================================================
# Utility Functions
# ========================================================================

log() {
    echo -e "${GREEN}[$(date +'%Y-%m-%d %H:%M:%S')] $*${NC}"
}

warn() {
    echo -e "${YELLOW}[$(date +'%Y-%m-%d %H:%M:%S')] WARNING: $*${NC}" >&2
}

error() {
    echo -e "${RED}[$(date +'%Y-%m-%d %H:%M:%S')] ERROR: $*${NC}" >&2
}

info() {
    echo -e "${BLUE}[$(date +'%Y-%m-%d %H:%M:%S')] INFO: $*${NC}"
}

# Check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Wait for rollout to complete
wait_for_rollout() {
    local resource_type="$1"
    local resource_name="$2"
    local timeout="${3:-300}"
    
    log "Waiting for $resource_type/$resource_name rollout to complete..."
    
    if ! kubectl rollout status "$resource_type/$resource_name" \
        --namespace="$NAMESPACE" \
        --timeout="${timeout}s" \
        --context="$KUBE_CONTEXT"; then
        error "Rollout failed for $resource_type/$resource_name"
        return 1
    fi
    
    log "Rollout completed successfully for $resource_type/$resource_name"
}

# Check pod health
check_pod_health() {
    local app_label="$1"
    local expected_replicas="${2:-3}"
    
    log "Checking pod health for app=$app_label..."
    
    # Wait for pods to be ready
    local ready_pods
    local attempt=0
    local max_attempts=30
    
    while [ $attempt -lt $max_attempts ]; do
        ready_pods=$(kubectl get pods \
            --namespace="$NAMESPACE" \
            --context="$KUBE_CONTEXT" \
            -l "app=$app_label" \
            -o jsonpath='{.items[?(@.status.phase=="Running")].metadata.name}' | wc -w)
        
        if [ "$ready_pods" -ge "$expected_replicas" ]; then
            log "All pods are healthy ($ready_pods/$expected_replicas ready)"
            return 0
        fi
        
        info "Waiting for pods to be ready ($ready_pods/$expected_replicas ready)..."
        sleep 10
        ((attempt++))
    done
    
    error "Pod health check failed after $((max_attempts * 10)) seconds"
    kubectl get pods --namespace="$NAMESPACE" --context="$KUBE_CONTEXT" -l "app=$app_label"
    return 1
}

# Run health checks
run_health_checks() {
    log "Running comprehensive health checks..."
    
    # Check API health
    local service_ip
    service_ip=$(kubectl get service rlhf-contract-wizard-service \
        --namespace="$NAMESPACE" \
        --context="$KUBE_CONTEXT" \
        -o jsonpath='{.spec.clusterIP}')
    
    if [ -n "$service_ip" ]; then
        log "Testing API health endpoint..."
        
        # Port forward for testing
        kubectl port-forward service/rlhf-contract-wizard-service 8080:80 \
            --namespace="$NAMESPACE" \
            --context="$KUBE_CONTEXT" &
        local port_forward_pid=$!
        
        sleep 5  # Wait for port forward to establish
        
        if curl -f "http://localhost:8080/api/v1/health" >/dev/null 2>&1; then
            log "API health check passed"
        else
            warn "API health check failed"
        fi
        
        # Clean up port forward
        kill $port_forward_pid 2>/dev/null || true
    fi
    
    # Check database connectivity
    log "Checking database connectivity..."
    if kubectl exec -n "$NAMESPACE" --context="$KUBE_CONTEXT" \
        deployment/rlhf-contract-wizard -- \
        python -c "from src.database.connection import test_connection; test_connection()" >/dev/null 2>&1; then
        log "Database connectivity check passed"
    else
        warn "Database connectivity check failed"
    fi
    
    # Check metrics endpoint
    log "Checking metrics endpoint..."
    if kubectl port-forward service/rlhf-contract-wizard-service 9091:9090 \
        --namespace="$NAMESPACE" \
        --context="$KUBE_CONTEXT" &
    then
        local metrics_port_forward_pid=$!
        sleep 5
        
        if curl -f "http://localhost:9091/metrics" >/dev/null 2>&1; then
            log "Metrics endpoint check passed"
        else
            warn "Metrics endpoint check failed"
        fi
        
        kill $metrics_port_forward_pid 2>/dev/null || true
    fi
}

# Rollback deployment
rollback_deployment() {
    local deployment_name="$1"
    
    error "Rolling back deployment: $deployment_name"
    
    kubectl rollout undo deployment/"$deployment_name" \
        --namespace="$NAMESPACE" \
        --context="$KUBE_CONTEXT"
    
    wait_for_rollout "deployment" "$deployment_name" 180
    
    error "Rollback completed for $deployment_name"
}

# ========================================================================
# Pre-deployment Checks
# ========================================================================

pre_deployment_checks() {
    log "Running pre-deployment checks..."
    
    # Check required tools
    for tool in kubectl docker helm; do
        if ! command_exists "$tool"; then
            error "Required tool not found: $tool"
            exit 1
        fi
    done
    
    # Check kubectl context
    if ! kubectl config get-contexts | grep -q "$KUBE_CONTEXT"; then
        error "Kubernetes context not found: $KUBE_CONTEXT"
        exit 1
    fi
    
    # Set kubectl context
    kubectl config use-context "$KUBE_CONTEXT"
    
    # Check cluster connectivity
    if ! kubectl cluster-info >/dev/null 2>&1; then
        error "Cannot connect to Kubernetes cluster"
        exit 1
    fi
    
    # Check required files
    local required_files=(
        "$K8S_DIR/namespace.yaml"
        "$K8S_DIR/deployment.yaml"
        "$K8S_DIR/hpa.yaml"
        "$MONITORING_DIR/prometheus-config.yaml"
        "$PROJECT_ROOT/production_config.yaml"
    )
    
    for file in "${required_files[@]}"; do
        if [ ! -f "$file" ]; then
            error "Required file not found: $file"
            exit 1
        fi
    done
    
    # Check secrets (if not dry run)
    if [ "$DRY_RUN" != "true" ]; then
        local required_secrets=(
            "database-credentials"
            "redis-credentials"
            "jwt-secret"
            "blockchain-credentials"
        )
        
        for secret in "${required_secrets[@]}"; do
            if ! kubectl get secret "$secret" \
                --namespace="$NAMESPACE" \
                --context="$KUBE_CONTEXT" >/dev/null 2>&1; then
                warn "Secret not found: $secret (will need to be created manually)"
            fi
        done
    fi
    
    log "Pre-deployment checks completed successfully"
}

# ========================================================================
# Image Building and Registry Operations
# ========================================================================

build_and_push_image() {
    local image_name="terragonlabs/rlhf-contract-wizard"
    local full_image="${image_name}:${IMAGE_TAG}"
    
    log "Building Docker image: $full_image"
    
    # Build image
    if ! docker build \
        --target production \
        --tag "$full_image" \
        --build-arg VERSION="$IMAGE_TAG" \
        --build-arg BUILD_DATE="$(date -u +'%Y-%m-%dT%H:%M:%SZ')" \
        "$PROJECT_ROOT"; then
        error "Docker build failed"
        return 1
    fi
    
    # Run security scan
    log "Running security scan..."
    if command_exists "docker scan"; then
        docker scan "$full_image" || warn "Security scan found issues"
    elif command_exists "trivy"; then
        trivy image "$full_image" || warn "Security scan found issues"
    else
        warn "No security scanner available (docker scan or trivy)"
    fi
    
    # Push to registry
    if [ "$DRY_RUN" != "true" ]; then
        log "Pushing image to registry..."
        
        if ! docker push "$full_image"; then
            error "Docker push failed"
            return 1
        fi
        
        log "Image pushed successfully: $full_image"
    else
        info "DRY_RUN: Would push image $full_image"
    fi
}

# ========================================================================
# Database Migration
# ========================================================================

run_database_migration() {
    log "Running database migrations..."
    
    if [ "$DRY_RUN" = "true" ]; then
        info "DRY_RUN: Would run database migrations"
        return 0
    fi
    
    # Create migration job
    kubectl apply --context="$KUBE_CONTEXT" -f - <<EOF
apiVersion: batch/v1
kind: Job
metadata:
  name: db-migration-$(date +%s)
  namespace: $NAMESPACE
  labels:
    app: rlhf-contract-wizard
    job-type: migration
spec:
  ttlSecondsAfterFinished: 300
  template:
    spec:
      restartPolicy: Never
      containers:
      - name: migration
        image: terragonlabs/rlhf-contract-wizard:${IMAGE_TAG}
        command: ["python", "-m", "src.database.migration_runner"]
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: database-credentials
              key: url
        resources:
          requests:
            memory: "256Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "500m"
EOF
    
    # Wait for migration to complete
    local job_name
    job_name=$(kubectl get jobs --namespace="$NAMESPACE" --context="$KUBE_CONTEXT" \
        -l "job-type=migration" --sort-by=.metadata.creationTimestamp \
        -o jsonpath='{.items[-1].metadata.name}')
    
    if [ -n "$job_name" ]; then
        log "Waiting for migration job to complete: $job_name"
        
        if kubectl wait --for=condition=complete \
            "job/$job_name" \
            --namespace="$NAMESPACE" \
            --context="$KUBE_CONTEXT" \
            --timeout=300s; then
            log "Database migration completed successfully"
        else
            error "Database migration failed"
            kubectl logs "job/$job_name" --namespace="$NAMESPACE" --context="$KUBE_CONTEXT"
            return 1
        fi
    fi
}

# ========================================================================
# Kubernetes Deployment
# ========================================================================

deploy_to_kubernetes() {
    log "Deploying to Kubernetes cluster..."
    
    # Create namespace
    log "Creating namespace: $NAMESPACE"
    if [ "$DRY_RUN" = "true" ]; then
        kubectl apply --dry-run=client -f "$K8S_DIR/namespace.yaml" --context="$KUBE_CONTEXT"
    else
        kubectl apply -f "$K8S_DIR/namespace.yaml" --context="$KUBE_CONTEXT"
    fi
    
    # Deploy application
    log "Deploying application..."
    
    # Substitute environment variables in templates
    local temp_deployment="/tmp/deployment-${RANDOM}.yaml"
    envsubst < "$K8S_DIR/deployment.yaml" > "$temp_deployment"
    
    if [ "$DRY_RUN" = "true" ]; then
        kubectl apply --dry-run=client -f "$temp_deployment" --context="$KUBE_CONTEXT"
        kubectl apply --dry-run=client -f "$K8S_DIR/hpa.yaml" --context="$KUBE_CONTEXT"
    else
        # Apply deployment
        kubectl apply -f "$temp_deployment" --context="$KUBE_CONTEXT"
        kubectl apply -f "$K8S_DIR/hpa.yaml" --context="$KUBE_CONTEXT"
        
        # Wait for rollout
        wait_for_rollout "deployment" "rlhf-contract-wizard" 600
        
        # Check pod health
        check_pod_health "rlhf-contract-wizard" 3
    fi
    
    # Cleanup temp file
    rm -f "$temp_deployment"
    
    log "Kubernetes deployment completed"
}

# ========================================================================
# Monitoring Setup
# ========================================================================

setup_monitoring() {
    log "Setting up monitoring stack..."
    
    if [ "$DRY_RUN" = "true" ]; then
        kubectl apply --dry-run=client -f "$MONITORING_DIR/prometheus-config.yaml" --context="$KUBE_CONTEXT"
        info "DRY_RUN: Would deploy monitoring stack"
        return 0
    fi
    
    # Deploy Prometheus
    kubectl apply -f "$MONITORING_DIR/prometheus-config.yaml" --context="$KUBE_CONTEXT"
    
    # Wait for Prometheus to be ready
    wait_for_rollout "deployment" "prometheus" 300
    
    log "Monitoring stack deployed successfully"
}

# ========================================================================
# Configuration Management
# ========================================================================

deploy_configuration() {
    log "Deploying configuration..."
    
    # Create ConfigMap from production config
    local config_name="rlhf-config"
    
    if [ "$DRY_RUN" = "true" ]; then
        info "DRY_RUN: Would create ConfigMap $config_name"
        return 0
    fi
    
    # Delete existing ConfigMap if it exists
    kubectl delete configmap "$config_name" \
        --namespace="$NAMESPACE" \
        --context="$KUBE_CONTEXT" \
        --ignore-not-found=true
    
    # Create new ConfigMap
    kubectl create configmap "$config_name" \
        --from-file="$PROJECT_ROOT/production_config.yaml" \
        --namespace="$NAMESPACE" \
        --context="$KUBE_CONTEXT"
    
    log "Configuration deployed successfully"
}

# ========================================================================
# Testing and Validation
# ========================================================================

run_post_deployment_tests() {
    if [ "$SKIP_TESTS" = "true" ]; then
        warn "Skipping post-deployment tests"
        return 0
    fi
    
    log "Running post-deployment tests..."
    
    if [ "$DRY_RUN" = "true" ]; then
        info "DRY_RUN: Would run post-deployment tests"
        return 0
    fi
    
    # Create test job
    kubectl apply --context="$KUBE_CONTEXT" -f - <<EOF
apiVersion: batch/v1
kind: Job
metadata:
  name: post-deploy-tests-$(date +%s)
  namespace: $NAMESPACE
  labels:
    app: rlhf-contract-wizard
    job-type: test
spec:
  ttlSecondsAfterFinished: 600
  template:
    spec:
      restartPolicy: Never
      containers:
      - name: tests
        image: terragonlabs/rlhf-contract-wizard:${IMAGE_TAG}
        command: ["python", "-m", "pytest", "tests/integration/", "-v"]
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: database-credentials
              key: url
        - name: REDIS_URL
          valueFrom:
            secretKeyRef:
              name: redis-credentials
              key: url
        resources:
          requests:
            memory: "512Mi"
            cpu: "200m"
          limits:
            memory: "1Gi"
            cpu: "1000m"
EOF
    
    # Wait for tests to complete
    local test_job_name
    test_job_name=$(kubectl get jobs --namespace="$NAMESPACE" --context="$KUBE_CONTEXT" \
        -l "job-type=test" --sort-by=.metadata.creationTimestamp \
        -o jsonpath='{.items[-1].metadata.name}')
    
    if [ -n "$test_job_name" ]; then
        log "Waiting for test job to complete: $test_job_name"
        
        if kubectl wait --for=condition=complete \
            "job/$test_job_name" \
            --namespace="$NAMESPACE" \
            --context="$KUBE_CONTEXT" \
            --timeout=600s; then
            log "Post-deployment tests passed"
        else
            error "Post-deployment tests failed"
            kubectl logs "job/$test_job_name" --namespace="$NAMESPACE" --context="$KUBE_CONTEXT"
            return 1
        fi
    fi
}

# ========================================================================
# Backup and Recovery
# ========================================================================

create_backup() {
    log "Creating pre-deployment backup..."
    
    if [ "$DRY_RUN" = "true" ]; then
        info "DRY_RUN: Would create backup"
        return 0
    fi
    
    # Create backup job
    kubectl apply --context="$KUBE_CONTEXT" -f - <<EOF
apiVersion: batch/v1
kind: Job
metadata:
  name: backup-$(date +%s)
  namespace: $NAMESPACE
  labels:
    app: rlhf-contract-wizard
    job-type: backup
spec:
  ttlSecondsAfterFinished: 3600
  template:
    spec:
      restartPolicy: Never
      containers:
      - name: backup
        image: postgres:15-alpine
        command:
        - /bin/sh
        - -c
        - |
          pg_dump \$DATABASE_URL > /backup/backup-$(date +%Y%m%d-%H%M%S).sql
          echo "Backup completed successfully"
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: database-credentials
              key: url
        volumeMounts:
        - name: backup-storage
          mountPath: /backup
        resources:
          requests:
            memory: "256Mi"
            cpu: "100m"
      volumes:
      - name: backup-storage
        persistentVolumeClaim:
          claimName: backup-storage
EOF
    
    log "Backup job created"
}

# ========================================================================
# Main Deployment Workflow
# ========================================================================

main() {
    log "Starting RLHF-Contract-Wizard deployment..."
    log "Configuration:"
    log "  Environment: $ENVIRONMENT"
    log "  Namespace: $NAMESPACE"
    log "  Image Tag: $IMAGE_TAG"
    log "  Region: $REGION"
    log "  Kubernetes Context: $KUBE_CONTEXT"
    log "  Dry Run: $DRY_RUN"
    
    # Confirm deployment in production
    if [ "$ENVIRONMENT" = "production" ] && [ "$FORCE_DEPLOY" != "true" ] && [ "$DRY_RUN" != "true" ]; then
        echo -n "You are about to deploy to PRODUCTION. Are you sure? (yes/no): "
        read -r confirmation
        if [ "$confirmation" != "yes" ]; then
            log "Deployment cancelled by user"
            exit 0
        fi
    fi
    
    # Store deployment start time
    local deployment_start
    deployment_start=$(date +%s)
    
    # Set up error handling
    trap 'error "Deployment failed at step: $BASH_COMMAND"; exit 1' ERR
    
    # Deployment steps
    step=1
    
    info "Step $((step++)): Pre-deployment checks"
    pre_deployment_checks
    
    info "Step $((step++)): Building and pushing Docker image"
    if [ "$DRY_RUN" != "true" ]; then
        build_and_push_image
    else
        info "DRY_RUN: Skipping image build and push"
    fi
    
    info "Step $((step++)): Creating backup"
    create_backup
    
    info "Step $((step++)): Deploying configuration"
    deploy_configuration
    
    info "Step $((step++)): Running database migrations"
    run_database_migration
    
    info "Step $((step++)): Deploying to Kubernetes"
    deploy_to_kubernetes
    
    info "Step $((step++)): Setting up monitoring"
    setup_monitoring
    
    info "Step $((step++)): Running health checks"
    if [ "$DRY_RUN" != "true" ]; then
        run_health_checks
    else
        info "DRY_RUN: Skipping health checks"
    fi
    
    info "Step $((step++)): Running post-deployment tests"
    run_post_deployment_tests
    
    # Calculate deployment time
    local deployment_end
    deployment_end=$(date +%s)
    local deployment_time=$((deployment_end - deployment_start))
    
    log "âœ… Deployment completed successfully in ${deployment_time} seconds!"
    log "ðŸš€ RLHF-Contract-Wizard is now running in $ENVIRONMENT environment"
    
    # Display useful information
    if [ "$DRY_RUN" != "true" ]; then
        log "Useful commands:"
        log "  Monitor pods: kubectl get pods -n $NAMESPACE -w"
        log "  View logs: kubectl logs -f deployment/rlhf-contract-wizard -n $NAMESPACE"
        log "  Check metrics: kubectl port-forward svc/prometheus 9090:9090 -n $NAMESPACE"
        log "  Scale deployment: kubectl scale deployment rlhf-contract-wizard --replicas=5 -n $NAMESPACE"
    fi
}

# ========================================================================
# Script Entry Point
# ========================================================================

# Help function
show_help() {
    cat << EOF
RLHF-Contract-Wizard Deployment Script

USAGE:
    $0 [OPTIONS]

OPTIONS:
    -h, --help              Show this help message
    -n, --namespace NAME    Kubernetes namespace (default: $DEFAULT_NAMESPACE)
    -t, --tag TAG          Docker image tag (default: $DEFAULT_IMAGE_TAG)
    -e, --environment ENV  Environment (default: $DEFAULT_ENVIRONMENT)
    -r, --region REGION    AWS region (default: $DEFAULT_REGION)
    -c, --context CONTEXT  Kubernetes context (default: rlhf-prod-REGION)
    --dry-run              Perform a dry run without making changes
    --skip-tests           Skip post-deployment tests
    --force                Force deployment without confirmation

EXAMPLES:
    # Standard production deployment
    $0 --environment production --tag v1.2.0

    # Dry run to test configuration
    $0 --dry-run --environment staging

    # Deploy to specific region
    $0 --region us-west-2 --namespace rlhf-contracts-west

    # Force deployment without confirmation
    $0 --force --environment production

ENVIRONMENT VARIABLES:
    NAMESPACE              Override default namespace
    IMAGE_TAG              Override default image tag
    ENVIRONMENT            Override default environment
    REGION                 Override default region
    KUBE_CONTEXT           Override Kubernetes context
    DRY_RUN                Enable dry run mode (true/false)
    SKIP_TESTS             Skip tests (true/false)
    FORCE_DEPLOY           Force deployment (true/false)

EOF
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            exit 0
            ;;
        -n|--namespace)
            NAMESPACE="$2"
            shift 2
            ;;
        -t|--tag)
            IMAGE_TAG="$2"
            shift 2
            ;;
        -e|--environment)
            ENVIRONMENT="$2"
            shift 2
            ;;
        -r|--region)
            REGION="$2"
            shift 2
            ;;
        -c|--context)
            KUBE_CONTEXT="$2"
            shift 2
            ;;
        --dry-run)
            DRY_RUN="true"
            shift
            ;;
        --skip-tests)
            SKIP_TESTS="true"
            shift
            ;;
        --force)
            FORCE_DEPLOY="true"
            shift
            ;;
        *)
            error "Unknown option: $1"
            show_help
            exit 1
            ;;
    esac
done

# Update KUBE_CONTEXT with region if not explicitly set
if [[ "$KUBE_CONTEXT" == "rlhf-prod-"* ]]; then
    KUBE_CONTEXT="rlhf-prod-${REGION}"
fi

# Run main deployment
main "$@"